<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.eslintrc.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.eslintrc.json" />
              <option name="updatedContent" value="{&#10;  &quot;extends&quot;: &quot;next/core-web-vitals&quot;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/globals.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/globals.css" />
              <option name="updatedContent" value="@tailwind base;&#10;@tailwind components;&#10;@tailwind utilities;&#10;&#10;* {&#10;  margin: 0;&#10;  padding: 0;&#10;  box-sizing: border-box;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/layout.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/layout.tsx" />
              <option name="updatedContent" value="import &quot;./globals.css&quot;;&#10;&#10;export default function RootLayout({&#10;  children,&#10;}: {&#10;  children: React.ReactNode;&#10;}) {&#10;  return (&#10;    &lt;html lang=&quot;en&quot;&gt;&#10;      &lt;body&gt;{children}&lt;/body&gt;&#10;    &lt;/html&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/page.tsx" />
              <option name="updatedContent" value="export default function Home() {&#10;  return (&#10;    &lt;main&gt;&#10;      &lt;h1&gt;Hello World&lt;/h1&gt;&#10;    &lt;/main&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/next.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/next.config.js" />
              <option name="updatedContent" value="/** @type {import('next').NextConfig} */&#10;const nextConfig = {}&#10;&#10;module.exports = nextConfig&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;sds-test-task&quot;,&#10;  &quot;version&quot;: &quot;0.1.0&quot;,&#10;  &quot;private&quot;: true,&#10;  &quot;scripts&quot;: {&#10;    &quot;dev&quot;: &quot;next dev&quot;,&#10;    &quot;build&quot;: &quot;next build&quot;,&#10;    &quot;start&quot;: &quot;next start&quot;,&#10;    &quot;lint&quot;: &quot;next lint&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;react&quot;: &quot;^18.3.1&quot;,&#10;    &quot;react-dom&quot;: &quot;^18.3.1&quot;,&#10;    &quot;next&quot;: &quot;^15.0.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/node&quot;: &quot;^20&quot;,&#10;    &quot;@types/react&quot;: &quot;^18&quot;,&#10;    &quot;@types/react-dom&quot;: &quot;^18&quot;,&#10;    &quot;typescript&quot;: &quot;^5&quot;,&#10;    &quot;eslint&quot;: &quot;^8&quot;,&#10;    &quot;eslint-config-next&quot;: &quot;^15.0.0&quot;,&#10;    &quot;tailwindcss&quot;: &quot;^3.4.1&quot;,&#10;    &quot;postcss&quot;: &quot;^8&quot;,&#10;    &quot;autoprefixer&quot;: &quot;^10.0.1&quot;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/postcss.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/postcss.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  plugins: {&#10;    tailwindcss: {},&#10;    autoprefixer: {},&#10;  },&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tailwind.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tailwind.config.ts" />
              <option name="updatedContent" value="import type { Config } from &quot;tailwindcss&quot;;&#10;&#10;const config: Config = {&#10;  content: [&#10;    &quot;./pages/**/*.{js,ts,jsx,tsx,mdx}&quot;,&#10;    &quot;./components/**/*.{js,ts,jsx,tsx,mdx}&quot;,&#10;    &quot;./app/**/*.{js,ts,jsx,tsx,mdx}&quot;,&#10;  ],&#10;  theme: {&#10;    extend: {},&#10;  },&#10;  plugins: [],&#10;};&#10;export default config;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],&#10;    &quot;allowJs&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true,&#10;    &quot;noEmit&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;module&quot;: &quot;esnext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;isolatedModules&quot;: true,&#10;    &quot;jsx&quot;: &quot;preserve&quot;,&#10;    &quot;incremental&quot;: true,&#10;    &quot;plugins&quot;: [&#10;      {&#10;        &quot;name&quot;: &quot;next&quot;&#10;      }&#10;    ],&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;./*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;, &quot;.next/types/**/*.ts&quot;],&#10;  &quot;exclude&quot;: [&quot;node_modules&quot;]&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/components/task-dashboard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/components/task-dashboard.tsx" />
              <option name="originalContent" value="&quot;use client&quot;&#10;&#10;import { useState, useMemo, useCallback } from &quot;react&quot;&#10;import useSWR from &quot;swr&quot;&#10;import { Button } from &quot;@/components/ui/button&quot;&#10;import { TaskList } from &quot;./task-list&quot;&#10;import { TaskForm } from &quot;./task-form&quot;&#10;import { TaskFilters } from &quot;./task-filters&quot;&#10;import { TaskStats } from &quot;./task-stats&quot;&#10;import { LoadingOverlay } from &quot;./loading-overlay&quot;&#10;import { TaskDetailModal } from &quot;./task-detail-modal&quot;&#10;import { TaskPagination } from &quot;./task-pagination&quot;&#10;import { RefreshCw, Sparkles } from &quot;lucide-react&quot;&#10;import type { Task, CreateTaskInput, UpdateTaskInput, ApiResponse } from &quot;@/api/types&quot;&#10;import { useToast } from &quot;@/hooks/use-toast&quot;&#10;&#10;const fakeDelay = (min = 500, max = 1500) =&gt;&#10;  new Promise((resolve) =&gt; setTimeout(resolve, Math.random() * (max - min) + min))&#10;&#10;const fetcher = async (url: string) =&gt; {&#10;  await fakeDelay(800, 1500)&#10;  const res = await fetch(url)&#10;  const data: ApiResponse&lt;Task[]&gt; = await res.json()&#10;  if (!data.success) throw new Error(data.error)&#10;  return data.data&#10;}&#10;&#10;export function TaskDashboard() {&#10;  const { data: tasks, error, isLoading, mutate } = useSWR&lt;Task[]&gt;(&quot;/api/tasks&quot;, fetcher)&#10;  const { toast } = useToast()&#10;&#10;  const [isFormOpen, setIsFormOpen] = useState(false)&#10;  const [editingTask, setEditingTask] = useState&lt;Task | null&gt;(null)&#10;  const [statusFilter, setStatusFilter] = useState&lt;&quot;all&quot; | &quot;pending&quot; | &quot;completed&quot;&gt;(&quot;all&quot;)&#10;  const [priorityFilter, setPriorityFilter] = useState&lt;&quot;all&quot; | &quot;high&quot; | &quot;medium&quot; | &quot;low&quot;&gt;(&quot;all&quot;)&#10;  const [searchQuery, setSearchQuery] = useState(&quot;&quot;)&#10;  const [isRefreshing, setIsRefreshing] = useState(false)&#10;&#10;  const [isDetailOpen, setIsDetailOpen] = useState(false)&#10;  const [selectedTask, setSelectedTask] = useState&lt;Task | null&gt;(null)&#10;&#10;  const [loadingState, setLoadingState] = useState&lt;{&#10;    isLoading: boolean&#10;    message: string&#10;  }&gt;({ isLoading: false, message: &quot;&quot; })&#10;&#10;  const [currentPage, setCurrentPage] = useState(1)&#10;  const [itemsPerPage, setItemsPerPage] = useState(10)&#10;&#10;  const filteredTasks = useMemo(() =&gt; {&#10;    if (!tasks) return []&#10;&#10;    return tasks.filter((task) =&gt; {&#10;      if (statusFilter !== &quot;all&quot; &amp;&amp; task.status !== statusFilter) return false&#10;      if (priorityFilter !== &quot;all&quot; &amp;&amp; task.priority !== priorityFilter) return false&#10;      if (searchQuery) {&#10;        const query = searchQuery.toLowerCase()&#10;        return task.title.toLowerCase().includes(query) || task.description?.toLowerCase().includes(query)&#10;      }&#10;      return true&#10;    })&#10;  }, [tasks, statusFilter, priorityFilter, searchQuery])&#10;&#10;  const paginatedTasks = useMemo(() =&gt; {&#10;    const startIndex = (currentPage - 1) * itemsPerPage&#10;    const endIndex = startIndex + itemsPerPage&#10;    return filteredTasks.slice(startIndex, endIndex)&#10;  }, [filteredTasks, currentPage, itemsPerPage])&#10;&#10;  const totalPages = Math.ceil(filteredTasks.length / itemsPerPage)&#10;&#10;  useEffect(() =&gt; {&#10;    setCurrentPage(1)&#10;  }, [statusFilter, priorityFilter, searchQuery, itemsPerPage])&#10;&#10;  const handleRefresh = useCallback(async () =&gt; {&#10;    setIsRefreshing(true)&#10;    setLoadingState({ isLoading: true, message: &quot;Refreshing tasks...&quot; })&#10;    await fakeDelay(600, 1200)&#10;    await mutate()&#10;    setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;    setIsRefreshing(false)&#10;  }, [mutate])&#10;&#10;  const handleCreateTask = useCallback(&#10;    async (data: CreateTaskInput | UpdateTaskInput) =&gt; {&#10;      setLoadingState({ isLoading: true, message: &quot;Creating task...&quot; })&#10;      await fakeDelay(800, 1500)&#10;&#10;      const res = await fetch(&quot;/api/tasks&quot;, {&#10;        method: &quot;POST&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to create task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task created successfully&quot;,&#10;      })&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleUpdateTask = useCallback(&#10;    async (data: CreateTaskInput | UpdateTaskInput) =&gt; {&#10;      if (!editingTask) return&#10;&#10;      setLoadingState({ isLoading: true, message: &quot;Saving changes...&quot; })&#10;      await fakeDelay(600, 1200)&#10;&#10;      const res = await fetch(`/api/tasks/${editingTask.id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      setEditingTask(null)&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task updated successfully&quot;,&#10;      })&#10;    },&#10;    [editingTask, mutate, toast],&#10;  )&#10;&#10;  const handleInlineUpdate = useCallback(&#10;    async (id: string, data: UpdateTaskInput) =&gt; {&#10;      await fakeDelay(400, 800)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      if (selectedTask &amp;&amp; result.data) {&#10;        setSelectedTask(result.data)&#10;      }&#10;    },&#10;    [mutate, toast, selectedTask],&#10;  )&#10;&#10;  const handleDeleteTask = useCallback(&#10;    async (id: string) =&gt; {&#10;      setLoadingState({ isLoading: true, message: &quot;Deleting task...&quot; })&#10;      await fakeDelay(600, 1000)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;DELETE&quot;,&#10;      })&#10;      const result: ApiResponse = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to delete task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        return&#10;      }&#10;&#10;      await mutate()&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task deleted successfully&quot;,&#10;      })&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleToggleStatus = useCallback(&#10;    async (id: string, status: &quot;pending&quot; | &quot;completed&quot;) =&gt; {&#10;      await fakeDelay(400, 800)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify({ status }),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task status&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        return&#10;      }&#10;&#10;      await mutate()&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleEdit = useCallback((task: Task) =&gt; {&#10;    setEditingTask(task)&#10;    setIsFormOpen(true)&#10;  }, [])&#10;&#10;  const handleFormClose = useCallback((open: boolean) =&gt; {&#10;    setIsFormOpen(open)&#10;    if (!open) setEditingTask(null)&#10;  }, [])&#10;&#10;  const handleTaskClick = useCallback((task: Task) =&gt; {&#10;    setSelectedTask(task)&#10;    setIsDetailOpen(true)&#10;  }, [])&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col items-center justify-center min-h-[400px] text-center px-4&quot;&gt;&#10;        &lt;p className=&quot;text-destructive mb-4&quot;&gt;Failed to load tasks&lt;/p&gt;&#10;        &lt;Button onClick={handleRefresh}&gt;Try Again&lt;/Button&gt;&#10;      &lt;/div&gt;&#10;    )&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4 sm:space-y-6&quot;&gt;&#10;      &lt;LoadingOverlay isVisible={loadingState.isLoading} message={loadingState.message} /&gt;&#10;&#10;      &lt;TaskStats tasks={tasks || []} /&gt;&#10;&#10;      &lt;div className=&quot;space-y-3&quot;&gt;&#10;        &lt;TaskFilters&#10;          statusFilter={statusFilter}&#10;          onStatusFilterChange={setStatusFilter}&#10;          priorityFilter={priorityFilter}&#10;          onPriorityFilterChange={setPriorityFilter}&#10;          searchQuery={searchQuery}&#10;          onSearchChange={setSearchQuery}&#10;        /&gt;&#10;&#10;        &lt;div className=&quot;flex gap-2 justify-start&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            size=&quot;icon&quot;&#10;            onClick={handleRefresh}&#10;            disabled={isRefreshing}&#10;            aria-label=&quot;Refresh tasks&quot;&#10;            className=&quot;shrink-0 bg-transparent h-10 w-10&quot;&#10;          &gt;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isRefreshing ? &quot;animate-spin&quot; : &quot;&quot;}`} /&gt;&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={() =&gt; setIsFormOpen(true)}&#10;            className=&quot;flex-1 sm:flex-none bg-gradient-to-r from-primary to-primary/80 hover:from-primary/90 hover:to-primary/70 shadow-md hover:shadow-lg transition-all duration-200&quot;&#10;          &gt;&#10;            &lt;Sparkles className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;font-medium&quot;&gt;New Task&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;TaskList&#10;        tasks={paginatedTasks}&#10;        onEdit={handleEdit}&#10;        onDelete={handleDeleteTask}&#10;        onToggleStatus={handleToggleStatus}&#10;        onClick={handleTaskClick}&#10;        isLoading={isLoading}&#10;      /&gt;&#10;&#10;      {filteredTasks.length &gt; 0 &amp;&amp; (&#10;        &lt;TaskPagination&#10;          currentPage={currentPage}&#10;          totalPages={totalPages}&#10;          itemsPerPage={itemsPerPage}&#10;          totalItems={filteredTasks.length}&#10;          onPageChange={setCurrentPage}&#10;          onItemsPerPageChange={setItemsPerPage}&#10;        /&gt;&#10;      )}&#10;&#10;      &lt;TaskForm&#10;        open={isFormOpen}&#10;        onOpenChange={handleFormClose}&#10;        task={editingTask}&#10;        onSubmit={editingTask ? handleUpdateTask : handleCreateTask}&#10;      /&gt;&#10;&#10;      &lt;TaskDetailModal&#10;        open={isDetailOpen}&#10;        onOpenChange={setIsDetailOpen}&#10;        task={selectedTask}&#10;        onUpdate={handleInlineUpdate}&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  )&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;&#10;&#10;import { useState, useMemo, useEffect, useCallback } from &quot;react&quot;&#10;import useSWR from &quot;swr&quot;&#10;import { Button } from &quot;@/components/ui/button&quot;&#10;import { TaskList } from &quot;./task-list&quot;&#10;import { TaskForm } from &quot;./task-form&quot;&#10;import { TaskFilters } from &quot;./task-filters&quot;&#10;import { TaskStats } from &quot;./task-stats&quot;&#10;import { LoadingOverlay } from &quot;./loading-overlay&quot;&#10;import { TaskDetailModal } from &quot;./task-detail-modal&quot;&#10;import { TaskPagination } from &quot;./task-pagination&quot;&#10;import { RefreshCw, Sparkles } from &quot;lucide-react&quot;&#10;import type { Task, CreateTaskInput, UpdateTaskInput, ApiResponse } from &quot;@/api/types&quot;&#10;import { useToast } from &quot;@/hooks/use-toast&quot;&#10;&#10;const fakeDelay = (min = 500, max = 1500) =&gt;&#10;  new Promise((resolve) =&gt; setTimeout(resolve, Math.random() * (max - min) + min))&#10;&#10;const fetcher = async (url: string) =&gt; {&#10;  await fakeDelay(800, 1500)&#10;  const res = await fetch(url)&#10;  const data: ApiResponse&lt;Task[]&gt; = await res.json()&#10;  if (!data.success) throw new Error(data.error)&#10;  return data.data&#10;}&#10;&#10;export function TaskDashboard() {&#10;  const { data: tasks, error, isLoading, mutate } = useSWR&lt;Task[]&gt;(&quot;/api/tasks&quot;, fetcher)&#10;  const { toast } = useToast()&#10;&#10;  const [isFormOpen, setIsFormOpen] = useState(false)&#10;  const [editingTask, setEditingTask] = useState&lt;Task | null&gt;(null)&#10;  const [statusFilter, setStatusFilter] = useState&lt;&quot;all&quot; | &quot;pending&quot; | &quot;completed&quot;&gt;(&quot;all&quot;)&#10;  const [priorityFilter, setPriorityFilter] = useState&lt;&quot;all&quot; | &quot;high&quot; | &quot;medium&quot; | &quot;low&quot;&gt;(&quot;all&quot;)&#10;  const [searchQuery, setSearchQuery] = useState(&quot;&quot;)&#10;  const [isRefreshing, setIsRefreshing] = useState(false)&#10;&#10;  const [isDetailOpen, setIsDetailOpen] = useState(false)&#10;  const [selectedTask, setSelectedTask] = useState&lt;Task | null&gt;(null)&#10;&#10;  const [loadingState, setLoadingState] = useState&lt;{&#10;    isLoading: boolean&#10;    message: string&#10;  }&gt;({ isLoading: false, message: &quot;&quot; })&#10;&#10;  const [currentPage, setCurrentPage] = useState(1)&#10;  const [itemsPerPage, setItemsPerPage] = useState(10)&#10;&#10;  const filteredTasks = useMemo(() =&gt; {&#10;    if (!tasks) return []&#10;&#10;    return tasks.filter((task) =&gt; {&#10;      if (statusFilter !== &quot;all&quot; &amp;&amp; task.status !== statusFilter) return false&#10;      if (priorityFilter !== &quot;all&quot; &amp;&amp; task.priority !== priorityFilter) return false&#10;      if (searchQuery) {&#10;        const query = searchQuery.toLowerCase()&#10;        return task.title.toLowerCase().includes(query) || task.description?.toLowerCase().includes(query)&#10;      }&#10;      return true&#10;    })&#10;  }, [tasks, statusFilter, priorityFilter, searchQuery])&#10;&#10;  const paginatedTasks = useMemo(() =&gt; {&#10;    const startIndex = (currentPage - 1) * itemsPerPage&#10;    const endIndex = startIndex + itemsPerPage&#10;    return filteredTasks.slice(startIndex, endIndex)&#10;  }, [filteredTasks, currentPage, itemsPerPage])&#10;&#10;  const totalPages = Math.ceil(filteredTasks.length / itemsPerPage)&#10;&#10;  useEffect(() =&gt; {&#10;    setCurrentPage(1)&#10;  }, [statusFilter, priorityFilter, searchQuery, itemsPerPage])&#10;&#10;  const handleRefresh = useCallback(async () =&gt; {&#10;    setIsRefreshing(true)&#10;    setLoadingState({ isLoading: true, message: &quot;Refreshing tasks...&quot; })&#10;    await fakeDelay(600, 1200)&#10;    await mutate()&#10;    setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;    setIsRefreshing(false)&#10;  }, [mutate])&#10;&#10;  const handleCreateTask = useCallback(&#10;    async (data: CreateTaskInput | UpdateTaskInput) =&gt; {&#10;      setLoadingState({ isLoading: true, message: &quot;Creating task...&quot; })&#10;      await fakeDelay(800, 1500)&#10;&#10;      const res = await fetch(&quot;/api/tasks&quot;, {&#10;        method: &quot;POST&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to create task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task created successfully&quot;,&#10;      })&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleUpdateTask = useCallback(&#10;    async (data: CreateTaskInput | UpdateTaskInput) =&gt; {&#10;      if (!editingTask) return&#10;&#10;      setLoadingState({ isLoading: true, message: &quot;Saving changes...&quot; })&#10;      await fakeDelay(600, 1200)&#10;&#10;      const res = await fetch(`/api/tasks/${editingTask.id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      setEditingTask(null)&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task updated successfully&quot;,&#10;      })&#10;    },&#10;    [editingTask, mutate, toast],&#10;  )&#10;&#10;  const handleInlineUpdate = useCallback(&#10;    async (id: string, data: UpdateTaskInput) =&gt; {&#10;      await fakeDelay(400, 800)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify(data),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        throw new Error(result.error)&#10;      }&#10;&#10;      await mutate()&#10;      if (selectedTask &amp;&amp; result.data) {&#10;        setSelectedTask(result.data)&#10;      }&#10;    },&#10;    [mutate, toast, selectedTask],&#10;  )&#10;&#10;  const handleDeleteTask = useCallback(&#10;    async (id: string) =&gt; {&#10;      setLoadingState({ isLoading: true, message: &quot;Deleting task...&quot; })&#10;      await fakeDelay(600, 1000)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;DELETE&quot;,&#10;      })&#10;      const result: ApiResponse = await res.json()&#10;&#10;      if (!result.success) {&#10;        setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to delete task&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        return&#10;      }&#10;&#10;      await mutate()&#10;      setLoadingState({ isLoading: false, message: &quot;&quot; })&#10;      toast({&#10;        title: &quot;Success&quot;,&#10;        description: &quot;Task deleted successfully&quot;,&#10;      })&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleToggleStatus = useCallback(&#10;    async (id: string, status: &quot;pending&quot; | &quot;completed&quot;) =&gt; {&#10;      await fakeDelay(400, 800)&#10;&#10;      const res = await fetch(`/api/tasks/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify({ status }),&#10;      })&#10;      const result: ApiResponse&lt;Task&gt; = await res.json()&#10;&#10;      if (!result.success) {&#10;        toast({&#10;          title: &quot;Error&quot;,&#10;          description: result.error || &quot;Failed to update task status&quot;,&#10;          variant: &quot;destructive&quot;,&#10;        })&#10;        return&#10;      }&#10;&#10;      await mutate()&#10;    },&#10;    [mutate, toast],&#10;  )&#10;&#10;  const handleEdit = useCallback((task: Task) =&gt; {&#10;    setEditingTask(task)&#10;    setIsFormOpen(true)&#10;  }, [])&#10;&#10;  const handleFormClose = useCallback((open: boolean) =&gt; {&#10;    setIsFormOpen(open)&#10;    if (!open) setEditingTask(null)&#10;  }, [])&#10;&#10;  const handleTaskClick = useCallback((task: Task) =&gt; {&#10;    setSelectedTask(task)&#10;    setIsDetailOpen(true)&#10;  }, [])&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col items-center justify-center min-h-[400px] text-center px-4&quot;&gt;&#10;        &lt;p className=&quot;text-destructive mb-4&quot;&gt;Failed to load tasks&lt;/p&gt;&#10;        &lt;Button onClick={handleRefresh}&gt;Try Again&lt;/Button&gt;&#10;      &lt;/div&gt;&#10;    )&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4 sm:space-y-6&quot;&gt;&#10;      &lt;LoadingOverlay isVisible={loadingState.isLoading} message={loadingState.message} /&gt;&#10;&#10;      &lt;TaskStats tasks={tasks || []} /&gt;&#10;&#10;      &lt;div className=&quot;space-y-3&quot;&gt;&#10;        &lt;TaskFilters&#10;          statusFilter={statusFilter}&#10;          onStatusFilterChange={setStatusFilter}&#10;          priorityFilter={priorityFilter}&#10;          onPriorityFilterChange={setPriorityFilter}&#10;          searchQuery={searchQuery}&#10;          onSearchChange={setSearchQuery}&#10;        /&gt;&#10;&#10;        &lt;div className=&quot;flex gap-2 justify-start&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            size=&quot;icon&quot;&#10;            onClick={handleRefresh}&#10;            disabled={isRefreshing}&#10;            aria-label=&quot;Refresh tasks&quot;&#10;            className=&quot;shrink-0 bg-transparent h-10 w-10&quot;&#10;          &gt;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isRefreshing ? &quot;animate-spin&quot; : &quot;&quot;}`} /&gt;&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={() =&gt; setIsFormOpen(true)}&#10;            className=&quot;flex-1 sm:flex-none bg-gradient-to-r from-primary to-primary/80 hover:from-primary/90 hover:to-primary/70 shadow-md hover:shadow-lg transition-all duration-200&quot;&#10;          &gt;&#10;            &lt;Sparkles className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;font-medium&quot;&gt;New Task&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;TaskList&#10;        tasks={paginatedTasks}&#10;        onEdit={handleEdit}&#10;        onDelete={handleDeleteTask}&#10;        onToggleStatus={handleToggleStatus}&#10;        onClick={handleTaskClick}&#10;        isLoading={isLoading}&#10;      /&gt;&#10;&#10;      {filteredTasks.length &gt; 0 &amp;&amp; (&#10;        &lt;TaskPagination&#10;          currentPage={currentPage}&#10;          totalPages={totalPages}&#10;          itemsPerPage={itemsPerPage}&#10;          totalItems={filteredTasks.length}&#10;          onPageChange={setCurrentPage}&#10;          onItemsPerPageChange={setItemsPerPage}&#10;        /&gt;&#10;      )}&#10;&#10;      &lt;TaskForm&#10;        open={isFormOpen}&#10;        onOpenChange={handleFormClose}&#10;        task={editingTask}&#10;        onSubmit={editingTask ? handleUpdateTask : handleCreateTask}&#10;      /&gt;&#10;&#10;      &lt;TaskDetailModal&#10;        open={isDetailOpen}&#10;        onOpenChange={setIsDetailOpen}&#10;        task={selectedTask}&#10;        onUpdate={handleInlineUpdate}&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/components/task-detail-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/components/task-detail-modal.tsx" />
              <option name="originalContent" value="&quot;use client&quot;&#10;&#10;import { useState, useRef, useEffect } from &quot;react&quot;&#10;import { Dialog, DialogContent, DialogHeader, DialogTitle } from &quot;@/components/ui/dialog&quot;&#10;import { Badge } from &quot;@/components/ui/badge&quot;&#10;import { Input } from &quot;@/components/ui/input&quot;&#10;import { Textarea } from &quot;@/components/ui/textarea&quot;&#10;import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from &quot;@/components/ui/select&quot;&#10;import { Calendar, Clock, Flag, AlignLeft, Type, Loader2 } from &quot;lucide-react&quot;&#10;import type { Task, UpdateTaskInput } from &quot;@/api/types&quot;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;interface TaskDetailModalProps {&#10;  open: boolean&#10;  onOpenChange: (open: boolean) =&gt; void&#10;  task: Task | null&#10;  onUpdate: (id: string, data: UpdateTaskInput) =&gt; Promise&lt;void&gt;&#10;}&#10;&#10;const priorityDots = {&#10;  high: &quot;bg-red-500&quot;,&#10;  medium: &quot;bg-amber-500&quot;,&#10;  low: &quot;bg-emerald-500&quot;,&#10;}&#10;&#10;const statusColors = {&#10;  pending: &quot;bg-blue-500/10 text-blue-500 border-blue-500/20&quot;,&#10;  completed: &quot;bg-emerald-500/10 text-emerald-500 border-emerald-500/20&quot;,&#10;}&#10;&#10;export function TaskDetailModal({ open, onOpenChange, task, onUpdate }: TaskDetailModalProps) {&#10;  const [isLoading, setIsLoading] = useState(true)&#10;  const [isSaving, setIsSaving] = useState(false)&#10;  const [editingField, setEditingField] = useState&lt;string | null&gt;(null)&#10;  const [localTask, setLocalTask] = useState&lt;Task | null&gt;(null)&#10;&#10;  const titleInputRef = useRef&lt;HTMLInputElement&gt;(null)&#10;  const descriptionInputRef = useRef&lt;HTMLTextAreaElement&gt;(null)&#10;&#10;  // Simulate loading when modal opens&#10;  useEffect(() =&gt; {&#10;    if (open &amp;&amp; task) {&#10;      setIsLoading(true)&#10;      setLocalTask(task)&#10;      const timer = setTimeout(&#10;        () =&gt; {&#10;          setIsLoading(false)&#10;        },&#10;        500 + Math.random() * 500,&#10;      ) // 0.5-1s fake loading&#10;      return () =&gt; clearTimeout(timer)&#10;    }&#10;  }, [open, task])&#10;&#10;  // Focus input when editing starts&#10;  useEffect(() =&gt; {&#10;    if (editingField === &quot;title&quot; &amp;&amp; titleInputRef.current) {&#10;      titleInputRef.current.focus()&#10;      titleInputRef.current.select()&#10;    }&#10;    if (editingField === &quot;description&quot; &amp;&amp; descriptionInputRef.current) {&#10;      descriptionInputRef.current.focus()&#10;      descriptionInputRef.current.select()&#10;    }&#10;  }, [editingField])&#10;&#10;  const handleSaveField = async (field: string, value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    const updateData: UpdateTaskInput = { [field]: value }&#10;&#10;    // Don't save if value hasn't changed&#10;    if (localTask[field as keyof Task] === value) {&#10;      setEditingField(null)&#10;      return&#10;    }&#10;&#10;    setIsSaving(true)&#10;    setEditingField(null)&#10;&#10;    try {&#10;      await onUpdate(task.id, updateData)&#10;      setLocalTask({ ...localTask, [field]: value })&#10;    } catch (error) {&#10;      console.log(error.message, error.stack)&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const handleSelectChange = async (field: string, value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    setIsSaving(true)&#10;    setLocalTask({ ...localTask, [field]: value })&#10;&#10;    try {&#10;      await onUpdate(task.id, { [field]: value })&#10;    } catch (error) {&#10;        console.log(error.message, error.stack);&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const handleDateChange = async (value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    setIsSaving(true)&#10;    setLocalTask({ ...localTask, dueDate: value || undefined })&#10;&#10;    try {&#10;      await onUpdate(task.id, { dueDate: value || undefined })&#10;    } catch (_error: { message: string }) {&#10;        console.log(_error.message);&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const formatDate = (dateString?: string) =&gt; {&#10;    if (!dateString) return &quot;Not set&quot;&#10;    const date = new Date(dateString)&#10;    return date.toLocaleDateString(&quot;en-US&quot;, {&#10;      weekday: &quot;long&quot;,&#10;      month: &quot;long&quot;,&#10;      day: &quot;numeric&quot;,&#10;      year: &quot;numeric&quot;,&#10;    })&#10;  }&#10;&#10;  const formatDateForInput = (dateString?: string) =&gt; {&#10;    if (!dateString) return &quot;&quot;&#10;    const date = new Date(dateString)&#10;    return date.toISOString().split(&quot;T&quot;)[0]&#10;  }&#10;&#10;  if (!task) return null&#10;&#10;  return (&#10;    &lt;Dialog open={open} onOpenChange={onOpenChange}&gt;&#10;      &lt;DialogContent className=&quot;w-[95vw] max-w-[550px] max-h-[90vh] overflow-y-auto p-4 sm:p-6&quot;&gt;&#10;        {isLoading ? (&#10;          &lt;div className=&quot;flex flex-col items-center justify-center py-12&quot;&gt;&#10;            &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-primary mb-4&quot; /&gt;&#10;            &lt;p className=&quot;text-muted-foreground&quot;&gt;Loading task details...&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        ) : localTask ? (&#10;          &lt;&gt;&#10;            &lt;DialogHeader className=&quot;pr-6 sm:pr-8&quot;&gt;&#10;              &lt;div className=&quot;flex items-center gap-2 mb-2 flex-wrap&quot;&gt;&#10;                &lt;Badge variant=&quot;outline&quot; className={cn(&quot;text-xs&quot;, statusColors[localTask.status])}&gt;&#10;                  {localTask.status.charAt(0).toUpperCase() + localTask.status.slice(1)}&#10;                &lt;/Badge&gt;&#10;                {isSaving &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center gap-1 text-xs text-muted-foreground&quot;&gt;&#10;                    &lt;Loader2 className=&quot;h-3 w-3 animate-spin&quot; /&gt;&#10;                    Saving...&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* Editable Title */}&#10;              {editingField === &quot;title&quot; ? (&#10;                &lt;Input&#10;                  ref={titleInputRef}&#10;                  defaultValue={localTask.title}&#10;                  className=&quot;text-lg sm:text-xl font-semibold&quot;&#10;                  onBlur={(e) =&gt; handleSaveField(&quot;title&quot;, e.target.value)}&#10;                  onKeyDown={(e) =&gt; {&#10;                    if (e.key === &quot;Enter&quot;) {&#10;                      handleSaveField(&quot;title&quot;, e.currentTarget.value)&#10;                    }&#10;                    if (e.key === &quot;Escape&quot;) {&#10;                      setEditingField(null)&#10;                    }&#10;                  }}&#10;                /&gt;&#10;              ) : (&#10;                &lt;DialogTitle&#10;                  className=&quot;text-lg sm:text-xl font-semibold cursor-pointer hover:bg-muted/50 rounded px-2 py-1 -mx-2 transition-colors break-words&quot;&#10;                  onClick={() =&gt; setEditingField(&quot;title&quot;)}&#10;                  title=&quot;Click to edit&quot;&#10;                &gt;&#10;                  {localTask.title}&#10;                &lt;/DialogTitle&gt;&#10;              )}&#10;            &lt;/DialogHeader&gt;&#10;&#10;            &lt;div className=&quot;space-y-5 sm:space-y-6 mt-4&quot;&gt;&#10;              {/* Description */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;AlignLeft className=&quot;h-4 w-4&quot; /&gt;&#10;                  Description&#10;                &lt;/div&gt;&#10;                {editingField === &quot;description&quot; ? (&#10;                  &lt;Textarea&#10;                    ref={descriptionInputRef}&#10;                    defaultValue={localTask.description || &quot;&quot;}&#10;                    placeholder=&quot;Add a description...&quot;&#10;                    className=&quot;min-h-[100px] resize-none text-sm sm:text-base&quot;&#10;                    onBlur={(e) =&gt; handleSaveField(&quot;description&quot;, e.target.value)}&#10;                    onKeyDown={(e) =&gt; {&#10;                      if (e.key === &quot;Escape&quot;) {&#10;                        setEditingField(null)&#10;                      }&#10;                    }}&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;p&#10;                    className={cn(&#10;                      &quot;text-sm rounded px-3 py-2 cursor-pointer hover:bg-muted/50 transition-colors min-h-[60px] break-words&quot;,&#10;                      localTask.description ? &quot;text-foreground&quot; : &quot;text-muted-foreground italic&quot;,&#10;                    )}&#10;                    onClick={() =&gt; setEditingField(&quot;description&quot;)}&#10;                    title=&quot;Click to edit&quot;&#10;                  &gt;&#10;                    {localTask.description || &quot;Click to add a description...&quot;}&#10;                  &lt;/p&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6&quot;&gt;&#10;                {/* Priority */}&#10;                &lt;div className=&quot;space-y-2&quot;&gt;&#10;                  &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                    &lt;Flag className=&quot;h-4 w-4&quot; /&gt;&#10;                    Priority&#10;                  &lt;/div&gt;&#10;                  &lt;Select value={localTask.priority} onValueChange={(value) =&gt; handleSelectChange(&quot;priority&quot;, value)}&gt;&#10;                    &lt;SelectTrigger className=&quot;w-full&quot;&gt;&#10;                      &lt;SelectValue&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className={cn(&quot;w-2 h-2 rounded-full&quot;, priorityDots[localTask.priority])} /&gt;&#10;                          {localTask.priority.charAt(0).toUpperCase() + localTask.priority.slice(1)}&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectValue&gt;&#10;                    &lt;/SelectTrigger&gt;&#10;                    &lt;SelectContent&gt;&#10;                      &lt;SelectItem value=&quot;high&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-red-500&quot; /&gt;&#10;                          High&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;medium&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-amber-500&quot; /&gt;&#10;                          Medium&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;low&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-emerald-500&quot; /&gt;&#10;                          Low&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                    &lt;/SelectContent&gt;&#10;                  &lt;/Select&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Status */}&#10;                &lt;div className=&quot;space-y-2&quot;&gt;&#10;                  &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                    &lt;Type className=&quot;h-4 w-4&quot; /&gt;&#10;                    Status&#10;                  &lt;/div&gt;&#10;                  &lt;Select value={localTask.status} onValueChange={(value) =&gt; handleSelectChange(&quot;status&quot;, value)}&gt;&#10;                    &lt;SelectTrigger className=&quot;w-full&quot;&gt;&#10;                      &lt;SelectValue&gt;{localTask.status.charAt(0).toUpperCase() + localTask.status.slice(1)}&lt;/SelectValue&gt;&#10;                    &lt;/SelectTrigger&gt;&#10;                    &lt;SelectContent&gt;&#10;                      &lt;SelectItem value=&quot;pending&quot;&gt;Pending&lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;completed&quot;&gt;Completed&lt;/SelectItem&gt;&#10;                    &lt;/SelectContent&gt;&#10;                  &lt;/Select&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;&#10;              {/* Due Date */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;Calendar className=&quot;h-4 w-4&quot; /&gt;&#10;                  Due Date&#10;                &lt;/div&gt;&#10;                &lt;Input&#10;                  type=&quot;date&quot;&#10;                  value={formatDateForInput(localTask.dueDate)}&#10;                  onChange={(e) =&gt; handleDateChange(e.target.value)}&#10;                  className=&quot;w-full sm:w-[200px]&quot;&#10;                /&gt;&#10;                {localTask.dueDate &amp;&amp; &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;{formatDate(localTask.dueDate)}&lt;/p&gt;}&#10;              &lt;/div&gt;&#10;&#10;              {/* Created At (Read-only) */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;Clock className=&quot;h-4 w-4&quot; /&gt;&#10;                  Created&#10;                &lt;/div&gt;&#10;                &lt;p className=&quot;text-sm text-foreground px-3 py-2 bg-muted/30 rounded break-words&quot;&gt;&#10;                  {formatDate(localTask.createdAt)}&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/&gt;&#10;        ) : null}&#10;      &lt;/DialogContent&gt;&#10;    &lt;/Dialog&gt;&#10;  )&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;&#10;&#10;import { useState, useRef, useEffect } from &quot;react&quot;&#10;import { Dialog, DialogContent, DialogHeader, DialogTitle } from &quot;@/components/ui/dialog&quot;&#10;import { Badge } from &quot;@/components/ui/badge&quot;&#10;import { Input } from &quot;@/components/ui/input&quot;&#10;import { Textarea } from &quot;@/components/ui/textarea&quot;&#10;import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from &quot;@/components/ui/select&quot;&#10;import { Calendar, Clock, Flag, AlignLeft, Type, Loader2 } from &quot;lucide-react&quot;&#10;import type { Task, UpdateTaskInput } from &quot;@/api/types&quot;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;interface TaskDetailModalProps {&#10;  open: boolean&#10;  onOpenChange: (open: boolean) =&gt; void&#10;  task: Task | null&#10;  onUpdate: (id: string, data: UpdateTaskInput) =&gt; Promise&lt;void&gt;&#10;}&#10;&#10;const priorityDots = {&#10;  high: &quot;bg-red-500&quot;,&#10;  medium: &quot;bg-amber-500&quot;,&#10;  low: &quot;bg-emerald-500&quot;,&#10;}&#10;&#10;const statusColors = {&#10;  pending: &quot;bg-blue-500/10 text-blue-500 border-blue-500/20&quot;,&#10;  completed: &quot;bg-emerald-500/10 text-emerald-500 border-emerald-500/20&quot;,&#10;}&#10;&#10;export function TaskDetailModal({ open, onOpenChange, task, onUpdate }: TaskDetailModalProps) {&#10;  const [isLoading, setIsLoading] = useState(true)&#10;  const [isSaving, setIsSaving] = useState(false)&#10;  const [editingField, setEditingField] = useState&lt;string | null&gt;(null)&#10;  const [localTask, setLocalTask] = useState&lt;Task | null&gt;(null)&#10;&#10;  const titleInputRef = useRef&lt;HTMLInputElement&gt;(null)&#10;  const descriptionInputRef = useRef&lt;HTMLTextAreaElement&gt;(null)&#10;&#10;  // Simulate loading when modal opens&#10;  useEffect(() =&gt; {&#10;    if (open &amp;&amp; task) {&#10;      setIsLoading(true)&#10;      setLocalTask(task)&#10;      const timer = setTimeout(&#10;        () =&gt; {&#10;          setIsLoading(false)&#10;        },&#10;        500 + Math.random() * 500,&#10;      ) // 0.5-1s fake loading&#10;      return () =&gt; clearTimeout(timer)&#10;    }&#10;  }, [open, task])&#10;&#10;  // Focus input when editing starts&#10;  useEffect(() =&gt; {&#10;    if (editingField === &quot;title&quot; &amp;&amp; titleInputRef.current) {&#10;      titleInputRef.current.focus()&#10;      titleInputRef.current.select()&#10;    }&#10;    if (editingField === &quot;description&quot; &amp;&amp; descriptionInputRef.current) {&#10;      descriptionInputRef.current.focus()&#10;      descriptionInputRef.current.select()&#10;    }&#10;  }, [editingField])&#10;&#10;  const handleSaveField = async (field: string, value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    const updateData: UpdateTaskInput = { [field]: value }&#10;&#10;    // Don't save if value hasn't changed&#10;    if (localTask[field as keyof Task] === value) {&#10;      setEditingField(null)&#10;      return&#10;    }&#10;&#10;    setIsSaving(true)&#10;    setEditingField(null)&#10;&#10;    try {&#10;      await onUpdate(task.id, updateData)&#10;      setLocalTask({ ...localTask, [field]: value })&#10;    } catch (error) {&#10;      console.log(error.message, error.stack)&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const handleSelectChange = async (field: string, value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    setIsSaving(true)&#10;    setLocalTask({ ...localTask, [field]: value })&#10;&#10;    try {&#10;      await onUpdate(task.id, { [field]: value })&#10;    } catch (error) {&#10;        console.log(error.message, error.stack);&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const handleDateChange = async (value: string) =&gt; {&#10;    if (!localTask || !task) return&#10;&#10;    setIsSaving(true)&#10;    setLocalTask({ ...localTask, dueDate: value || undefined })&#10;&#10;    try {&#10;      await onUpdate(task.id, { dueDate: value || undefined })&#10;    } catch (_error) {&#10;      setLocalTask(task)&#10;    } finally {&#10;      setIsSaving(false)&#10;    }&#10;  }&#10;&#10;  const formatDate = (dateString?: string) =&gt; {&#10;    if (!dateString) return &quot;Not set&quot;&#10;    const date = new Date(dateString)&#10;    return date.toLocaleDateString(&quot;en-US&quot;, {&#10;      weekday: &quot;long&quot;,&#10;      month: &quot;long&quot;,&#10;      day: &quot;numeric&quot;,&#10;      year: &quot;numeric&quot;,&#10;    })&#10;  }&#10;&#10;  const formatDateForInput = (dateString?: string) =&gt; {&#10;    if (!dateString) return &quot;&quot;&#10;    const date = new Date(dateString)&#10;    return date.toISOString().split(&quot;T&quot;)[0]&#10;  }&#10;&#10;  if (!task) return null&#10;&#10;  return (&#10;    &lt;Dialog open={open} onOpenChange={onOpenChange}&gt;&#10;      &lt;DialogContent className=&quot;w-[95vw] max-w-[550px] max-h-[90vh] overflow-y-auto p-4 sm:p-6&quot;&gt;&#10;        {isLoading ? (&#10;          &lt;div className=&quot;flex flex-col items-center justify-center py-12&quot;&gt;&#10;            &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-primary mb-4&quot; /&gt;&#10;            &lt;p className=&quot;text-muted-foreground&quot;&gt;Loading task details...&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        ) : localTask ? (&#10;          &lt;&gt;&#10;            &lt;DialogHeader className=&quot;pr-6 sm:pr-8&quot;&gt;&#10;              &lt;div className=&quot;flex items-center gap-2 mb-2 flex-wrap&quot;&gt;&#10;                &lt;Badge variant=&quot;outline&quot; className={cn(&quot;text-xs&quot;, statusColors[localTask.status])}&gt;&#10;                  {localTask.status.charAt(0).toUpperCase() + localTask.status.slice(1)}&#10;                &lt;/Badge&gt;&#10;                {isSaving &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center gap-1 text-xs text-muted-foreground&quot;&gt;&#10;                    &lt;Loader2 className=&quot;h-3 w-3 animate-spin&quot; /&gt;&#10;                    Saving...&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* Editable Title */}&#10;              {editingField === &quot;title&quot; ? (&#10;                &lt;Input&#10;                  ref={titleInputRef}&#10;                  defaultValue={localTask.title}&#10;                  className=&quot;text-lg sm:text-xl font-semibold&quot;&#10;                  onBlur={(e) =&gt; handleSaveField(&quot;title&quot;, e.target.value)}&#10;                  onKeyDown={(e) =&gt; {&#10;                    if (e.key === &quot;Enter&quot;) {&#10;                      handleSaveField(&quot;title&quot;, e.currentTarget.value)&#10;                    }&#10;                    if (e.key === &quot;Escape&quot;) {&#10;                      setEditingField(null)&#10;                    }&#10;                  }}&#10;                /&gt;&#10;              ) : (&#10;                &lt;DialogTitle&#10;                  className=&quot;text-lg sm:text-xl font-semibold cursor-pointer hover:bg-muted/50 rounded px-2 py-1 -mx-2 transition-colors break-words&quot;&#10;                  onClick={() =&gt; setEditingField(&quot;title&quot;)}&#10;                  title=&quot;Click to edit&quot;&#10;                &gt;&#10;                  {localTask.title}&#10;                &lt;/DialogTitle&gt;&#10;              )}&#10;            &lt;/DialogHeader&gt;&#10;&#10;            &lt;div className=&quot;space-y-5 sm:space-y-6 mt-4&quot;&gt;&#10;              {/* Description */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;AlignLeft className=&quot;h-4 w-4&quot; /&gt;&#10;                  Description&#10;                &lt;/div&gt;&#10;                {editingField === &quot;description&quot; ? (&#10;                  &lt;Textarea&#10;                    ref={descriptionInputRef}&#10;                    defaultValue={localTask.description || &quot;&quot;}&#10;                    placeholder=&quot;Add a description...&quot;&#10;                    className=&quot;min-h-[100px] resize-none text-sm sm:text-base&quot;&#10;                    onBlur={(e) =&gt; handleSaveField(&quot;description&quot;, e.target.value)}&#10;                    onKeyDown={(e) =&gt; {&#10;                      if (e.key === &quot;Escape&quot;) {&#10;                        setEditingField(null)&#10;                      }&#10;                    }}&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;p&#10;                    className={cn(&#10;                      &quot;text-sm rounded px-3 py-2 cursor-pointer hover:bg-muted/50 transition-colors min-h-[60px] break-words&quot;,&#10;                      localTask.description ? &quot;text-foreground&quot; : &quot;text-muted-foreground italic&quot;,&#10;                    )}&#10;                    onClick={() =&gt; setEditingField(&quot;description&quot;)}&#10;                    title=&quot;Click to edit&quot;&#10;                  &gt;&#10;                    {localTask.description || &quot;Click to add a description...&quot;}&#10;                  &lt;/p&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6&quot;&gt;&#10;                {/* Priority */}&#10;                &lt;div className=&quot;space-y-2&quot;&gt;&#10;                  &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                    &lt;Flag className=&quot;h-4 w-4&quot; /&gt;&#10;                    Priority&#10;                  &lt;/div&gt;&#10;                  &lt;Select value={localTask.priority} onValueChange={(value) =&gt; handleSelectChange(&quot;priority&quot;, value)}&gt;&#10;                    &lt;SelectTrigger className=&quot;w-full&quot;&gt;&#10;                      &lt;SelectValue&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className={cn(&quot;w-2 h-2 rounded-full&quot;, priorityDots[localTask.priority])} /&gt;&#10;                          {localTask.priority.charAt(0).toUpperCase() + localTask.priority.slice(1)}&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectValue&gt;&#10;                    &lt;/SelectTrigger&gt;&#10;                    &lt;SelectContent&gt;&#10;                      &lt;SelectItem value=&quot;high&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-red-500&quot; /&gt;&#10;                          High&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;medium&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-amber-500&quot; /&gt;&#10;                          Medium&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;low&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                          &lt;span className=&quot;w-2 h-2 rounded-full bg-emerald-500&quot; /&gt;&#10;                          Low&#10;                        &lt;/div&gt;&#10;                      &lt;/SelectItem&gt;&#10;                    &lt;/SelectContent&gt;&#10;                  &lt;/Select&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Status */}&#10;                &lt;div className=&quot;space-y-2&quot;&gt;&#10;                  &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                    &lt;Type className=&quot;h-4 w-4&quot; /&gt;&#10;                    Status&#10;                  &lt;/div&gt;&#10;                  &lt;Select value={localTask.status} onValueChange={(value) =&gt; handleSelectChange(&quot;status&quot;, value)}&gt;&#10;                    &lt;SelectTrigger className=&quot;w-full&quot;&gt;&#10;                      &lt;SelectValue&gt;{localTask.status.charAt(0).toUpperCase() + localTask.status.slice(1)}&lt;/SelectValue&gt;&#10;                    &lt;/SelectTrigger&gt;&#10;                    &lt;SelectContent&gt;&#10;                      &lt;SelectItem value=&quot;pending&quot;&gt;Pending&lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;completed&quot;&gt;Completed&lt;/SelectItem&gt;&#10;                    &lt;/SelectContent&gt;&#10;                  &lt;/Select&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;&#10;              {/* Due Date */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;Calendar className=&quot;h-4 w-4&quot; /&gt;&#10;                  Due Date&#10;                &lt;/div&gt;&#10;                &lt;Input&#10;                  type=&quot;date&quot;&#10;                  value={formatDateForInput(localTask.dueDate)}&#10;                  onChange={(e) =&gt; handleDateChange(e.target.value)}&#10;                  className=&quot;w-full sm:w-[200px]&quot;&#10;                /&gt;&#10;                {localTask.dueDate &amp;&amp; &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;{formatDate(localTask.dueDate)}&lt;/p&gt;}&#10;              &lt;/div&gt;&#10;&#10;              {/* Created At (Read-only) */}&#10;              &lt;div className=&quot;space-y-2&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 text-sm font-medium text-muted-foreground&quot;&gt;&#10;                  &lt;Clock className=&quot;h-4 w-4&quot; /&gt;&#10;                  Created&#10;                &lt;/div&gt;&#10;                &lt;p className=&quot;text-sm text-foreground px-3 py-2 bg-muted/30 rounded break-words&quot;&gt;&#10;                  {formatDate(localTask.createdAt)}&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/&gt;&#10;        ) : null}&#10;      &lt;/DialogContent&gt;&#10;    &lt;/Dialog&gt;&#10;  )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/components/ui/use-toast.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/components/ui/use-toast.ts" />
              <option name="originalContent" value="'use client'&#10;&#10;// Inspired by react-hot-toast library&#10;import * as React from 'react'&#10;&#10;import type { ToastActionElement, ToastProps } from '@/components/ui/toast'&#10;&#10;const TOAST_LIMIT = 1&#10;const TOAST_REMOVE_DELAY = 1000000&#10;&#10;type ToasterToast = ToastProps &amp; {&#10;  id: string&#10;  title?: React.ReactNode&#10;  description?: React.ReactNode&#10;  action?: ToastActionElement&#10;}&#10;&#10;const actionTypes = {&#10;  ADD_TOAST: 'ADD_TOAST',&#10;  UPDATE_TOAST: 'UPDATE_TOAST',&#10;  DISMISS_TOAST: 'DISMISS_TOAST',&#10;  REMOVE_TOAST: 'REMOVE_TOAST',&#10;} as const&#10;&#10;let count = 0&#10;&#10;function genId() {&#10;  count = (count + 1) % Number.MAX_SAFE_INTEGER&#10;  return count.toString()&#10;}&#10;&#10;type ActionType = typeof actionTypes&#10;&#10;type Action =&#10;  | {&#10;      type: ActionType['ADD_TOAST']&#10;      toast: ToasterToast&#10;    }&#10;  | {&#10;      type: ActionType['UPDATE_TOAST']&#10;      toast: Partial&lt;ToasterToast&gt;&#10;    }&#10;  | {&#10;      type: ActionType['DISMISS_TOAST']&#10;      toastId?: ToasterToast['id']&#10;    }&#10;  | {&#10;      type: ActionType['REMOVE_TOAST']&#10;      toastId?: ToasterToast['id']&#10;    }&#10;&#10;interface State {&#10;  toasts: ToasterToast[]&#10;}&#10;&#10;const toastTimeouts = new Map&lt;string, ReturnType&lt;typeof setTimeout&gt;&gt;()&#10;&#10;const addToRemoveQueue = (toastId: string) =&gt; {&#10;  if (toastTimeouts.has(toastId)) {&#10;    return&#10;  }&#10;&#10;  const timeout = setTimeout(() =&gt; {&#10;    toastTimeouts.delete(toastId)&#10;    dispatch({&#10;      type: 'REMOVE_TOAST',&#10;      toastId: toastId,&#10;    })&#10;  }, TOAST_REMOVE_DELAY)&#10;&#10;  toastTimeouts.set(toastId, timeout)&#10;}&#10;&#10;export const reducer = (state: State, action: Action): State =&gt; {&#10;  switch (action.type) {&#10;    case 'ADD_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),&#10;      }&#10;&#10;    case 'UPDATE_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === action.toast.id ? { ...t, ...action.toast } : t,&#10;        ),&#10;      }&#10;&#10;    case 'DISMISS_TOAST': {&#10;      const { toastId } = action&#10;&#10;      // ! Side effects ! - This could be extracted into a dismissToast() action,&#10;      // but I'll keep it here for simplicity&#10;      if (toastId) {&#10;        addToRemoveQueue(toastId)&#10;      } else {&#10;        state.toasts.forEach((toast) =&gt; {&#10;          addToRemoveQueue(toast.id)&#10;        })&#10;      }&#10;&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === toastId || toastId === undefined&#10;            ? {&#10;                ...t,&#10;                open: false,&#10;              }&#10;            : t,&#10;        ),&#10;      }&#10;    }&#10;    case 'REMOVE_TOAST':&#10;      if (action.toastId === undefined) {&#10;        return {&#10;          ...state,&#10;          toasts: [],&#10;        }&#10;      }&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.filter((t) =&gt; t.id !== action.toastId),&#10;      }&#10;  }&#10;}&#10;&#10;const listeners: Array&lt;(state: State) =&gt; void&gt; = []&#10;&#10;let memoryState: State = { toasts: [] }&#10;&#10;function dispatch(action: Action) {&#10;  memoryState = reducer(memoryState, action)&#10;  listeners.forEach((listener) =&gt; {&#10;    listener(memoryState)&#10;  })&#10;}&#10;&#10;type Toast = Omit&lt;ToasterToast, 'id'&gt;&#10;&#10;function toast({ ...props }: Toast) {&#10;  const id = genId()&#10;&#10;  const update = (props: ToasterToast) =&gt;&#10;    dispatch({&#10;      type: 'UPDATE_TOAST',&#10;      toast: { ...props, id },&#10;    })&#10;  const dismiss = () =&gt; dispatch({ type: 'DISMISS_TOAST', toastId: id })&#10;&#10;  dispatch({&#10;    type: 'ADD_TOAST',&#10;    toast: {&#10;      ...props,&#10;      id,&#10;      open: true,&#10;      onOpenChange: (open) =&gt; {&#10;        if (!open) dismiss()&#10;      },&#10;    },&#10;  })&#10;&#10;  return {&#10;    id: id,&#10;    dismiss,&#10;    update,&#10;  }&#10;}&#10;&#10;function useToast() {&#10;  const [state, setState] = React.useState&lt;State&gt;(memoryState)&#10;&#10;  React.useEffect(() =&gt; {&#10;    listeners.push(setState)&#10;    return () =&gt; {&#10;      const index = listeners.indexOf(setState)&#10;      if (index &gt; -1) {&#10;        listeners.splice(index, 1)&#10;      }&#10;    }&#10;  }, [state])&#10;&#10;  return {&#10;    ...state,&#10;    toast,&#10;    dismiss: (toastId?: string) =&gt; dispatch({ type: 'DISMISS_TOAST', toastId }),&#10;  }&#10;}&#10;&#10;export { useToast, toast }&#10;" />
              <option name="updatedContent" value="'use client'&#10;&#10;// Inspired by react-hot-toast library&#10;import * as React from 'react'&#10;&#10;import type { ToastActionElement, ToastProps } from '@/components/ui/toast'&#10;&#10;const TOAST_LIMIT = 1&#10;const TOAST_REMOVE_DELAY = 1000000&#10;&#10;type ToasterToast = ToastProps &amp; {&#10;  id: string&#10;  title?: React.ReactNode&#10;  description?: React.ReactNode&#10;  action?: ToastActionElement&#10;}&#10;&#10;let count = 0&#10;&#10;function genId() {&#10;  count = (count + 1) % Number.MAX_SAFE_INTEGER&#10;  return count.toString()&#10;}&#10;&#10;type Action =&#10;  | {&#10;      type: 'ADD_TOAST'&#10;      toast: ToasterToast&#10;    }&#10;  | {&#10;      type: 'UPDATE_TOAST'&#10;      toast: Partial&lt;ToasterToast&gt;&#10;    }&#10;  | {&#10;      type: 'DISMISS_TOAST'&#10;      toastId?: ToasterToast['id']&#10;    }&#10;  | {&#10;      type: 'REMOVE_TOAST'&#10;      toastId?: ToasterToast['id']&#10;    }&#10;&#10;interface State {&#10;  toasts: ToasterToast[]&#10;}&#10;&#10;const toastTimeouts = new Map&lt;string, ReturnType&lt;typeof setTimeout&gt;&gt;()&#10;&#10;const addToRemoveQueue = (toastId: string) =&gt; {&#10;  if (toastTimeouts.has(toastId)) {&#10;    return&#10;  }&#10;&#10;  const timeout = setTimeout(() =&gt; {&#10;    toastTimeouts.delete(toastId)&#10;    dispatch({&#10;      type: 'REMOVE_TOAST',&#10;      toastId: toastId,&#10;    })&#10;  }, TOAST_REMOVE_DELAY)&#10;&#10;  toastTimeouts.set(toastId, timeout)&#10;}&#10;&#10;export const reducer = (state: State, action: Action): State =&gt; {&#10;  switch (action.type) {&#10;    case 'ADD_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),&#10;      }&#10;&#10;    case 'UPDATE_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === action.toast.id ? { ...t, ...action.toast } : t,&#10;        ),&#10;      }&#10;&#10;    case 'DISMISS_TOAST': {&#10;      const { toastId } = action&#10;&#10;      // ! Side effects ! - This could be extracted into a dismissToast() action,&#10;      // but I'll keep it here for simplicity&#10;      if (toastId) {&#10;        addToRemoveQueue(toastId)&#10;      } else {&#10;        state.toasts.forEach((toast) =&gt; {&#10;          addToRemoveQueue(toast.id)&#10;        })&#10;      }&#10;&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === toastId || toastId === undefined&#10;            ? {&#10;                ...t,&#10;                open: false,&#10;              }&#10;            : t,&#10;        ),&#10;      }&#10;    }&#10;    case 'REMOVE_TOAST':&#10;      if (action.toastId === undefined) {&#10;        return {&#10;          ...state,&#10;          toasts: [],&#10;        }&#10;      }&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.filter((t) =&gt; t.id !== action.toastId),&#10;      }&#10;  }&#10;}&#10;&#10;const listeners: Array&lt;(state: State) =&gt; void&gt; = []&#10;&#10;let memoryState: State = { toasts: [] }&#10;&#10;function dispatch(action: Action) {&#10;  memoryState = reducer(memoryState, action)&#10;  listeners.forEach((listener) =&gt; {&#10;    listener(memoryState)&#10;  })&#10;}&#10;&#10;type Toast = Omit&lt;ToasterToast, 'id'&gt;&#10;&#10;function toast({ ...props }: Toast) {&#10;  const id = genId()&#10;&#10;  const update = (props: ToasterToast) =&gt;&#10;    dispatch({&#10;      type: 'UPDATE_TOAST',&#10;      toast: { ...props, id },&#10;    })&#10;  const dismiss = () =&gt; dispatch({ type: 'DISMISS_TOAST', toastId: id })&#10;&#10;  dispatch({&#10;    type: 'ADD_TOAST',&#10;    toast: {&#10;      ...props,&#10;      id,&#10;      open: true,&#10;      onOpenChange: (open) =&gt; {&#10;        if (!open) dismiss()&#10;      },&#10;    },&#10;  })&#10;&#10;  return {&#10;    id: id,&#10;    dismiss,&#10;    update,&#10;  }&#10;}&#10;&#10;function useToast() {&#10;  const [state, setState] = React.useState&lt;State&gt;(memoryState)&#10;&#10;  React.useEffect(() =&gt; {&#10;    listeners.push(setState)&#10;    return () =&gt; {&#10;      const index = listeners.indexOf(setState)&#10;      if (index &gt; -1) {&#10;        listeners.splice(index, 1)&#10;      }&#10;    }&#10;  }, [state])&#10;&#10;  return {&#10;    ...state,&#10;    toast,&#10;    dismiss: (toastId?: string) =&gt; dispatch({ type: 'DISMISS_TOAST', toastId }),&#10;  }&#10;}&#10;&#10;export { useToast, toast }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hooks/use-toast.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hooks/use-toast.ts" />
              <option name="originalContent" value="'use client'&#10;&#10;// Inspired by react-hot-toast library&#10;import * as React from 'react'&#10;&#10;import type { ToastActionElement, ToastProps } from '@/components/ui/toast'&#10;&#10;const TOAST_LIMIT = 1&#10;const TOAST_REMOVE_DELAY = 1000000&#10;&#10;type ToasterToast = ToastProps &amp; {&#10;  id: string&#10;  title?: React.ReactNode&#10;  description?: React.ReactNode&#10;  action?: ToastActionElement&#10;}&#10;&#10;const actionTypes = {&#10;  ADD_TOAST: 'ADD_TOAST',&#10;  UPDATE_TOAST: 'UPDATE_TOAST',&#10;  DISMISS_TOAST: 'DISMISS_TOAST',&#10;  REMOVE_TOAST: 'REMOVE_TOAST',&#10;} as const&#10;&#10;let count = 0&#10;&#10;function genId() {&#10;  count = (count + 1) % Number.MAX_SAFE_INTEGER&#10;  return count.toString()&#10;}&#10;&#10;type ActionType = typeof actionTypes&#10;&#10;type Action =&#10;  | {&#10;      type: ActionType['ADD_TOAST']&#10;      toast: ToasterToast&#10;    }&#10;  | {&#10;      type: ActionType['UPDATE_TOAST']&#10;      toast: Partial&lt;ToasterToast&gt;&#10;    }&#10;  | {&#10;      type: ActionType['DISMISS_TOAST']&#10;      toastId?: ToasterToast['id']&#10;    }&#10;  | {&#10;      type: ActionType['REMOVE_TOAST']&#10;      toastId?: ToasterToast['id']&#10;    }&#10;&#10;interface State {&#10;  toasts: ToasterToast[]&#10;}&#10;&#10;const toastTimeouts = new Map&lt;string, ReturnType&lt;typeof setTimeout&gt;&gt;()&#10;&#10;const addToRemoveQueue = (toastId: string) =&gt; {&#10;  if (toastTimeouts.has(toastId)) {&#10;    return&#10;  }&#10;&#10;  const timeout = setTimeout(() =&gt; {&#10;    toastTimeouts.delete(toastId)&#10;    dispatch({&#10;      type: 'REMOVE_TOAST',&#10;      toastId: toastId,&#10;    })&#10;  }, TOAST_REMOVE_DELAY)&#10;&#10;  toastTimeouts.set(toastId, timeout)&#10;}&#10;&#10;export const reducer = (state: State, action: Action): State =&gt; {&#10;  switch (action.type) {&#10;    case 'ADD_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),&#10;      }&#10;&#10;    case 'UPDATE_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === action.toast.id ? { ...t, ...action.toast } : t,&#10;        ),&#10;      }&#10;&#10;    case 'DISMISS_TOAST': {&#10;      const { toastId } = action&#10;&#10;      // ! Side effects ! - This could be extracted into a dismissToast() action,&#10;      // but I'll keep it here for simplicity&#10;      if (toastId) {&#10;        addToRemoveQueue(toastId)&#10;      } else {&#10;        state.toasts.forEach((toast) =&gt; {&#10;          addToRemoveQueue(toast.id)&#10;        })&#10;      }&#10;&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === toastId || toastId === undefined&#10;            ? {&#10;                ...t,&#10;                open: false,&#10;              }&#10;            : t,&#10;        ),&#10;      }&#10;    }&#10;    case 'REMOVE_TOAST':&#10;      if (action.toastId === undefined) {&#10;        return {&#10;          ...state,&#10;          toasts: [],&#10;        }&#10;      }&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.filter((t) =&gt; t.id !== action.toastId),&#10;      }&#10;  }&#10;}&#10;&#10;const listeners: Array&lt;(state: State) =&gt; void&gt; = []&#10;&#10;let memoryState: State = { toasts: [] }&#10;&#10;function dispatch(action: Action) {&#10;  memoryState = reducer(memoryState, action)&#10;  listeners.forEach((listener) =&gt; {&#10;    listener(memoryState)&#10;  })&#10;}&#10;&#10;type Toast = Omit&lt;ToasterToast, 'id'&gt;&#10;&#10;function toast({ ...props }: Toast) {&#10;  const id = genId()&#10;&#10;  const update = (props: ToasterToast) =&gt;&#10;    dispatch({&#10;      type: 'UPDATE_TOAST',&#10;      toast: { ...props, id },&#10;    })&#10;  const dismiss = () =&gt; dispatch({ type: 'DISMISS_TOAST', toastId: id })&#10;&#10;  dispatch({&#10;    type: 'ADD_TOAST',&#10;    toast: {&#10;      ...props,&#10;      id,&#10;      open: true,&#10;      onOpenChange: (open) =&gt; {&#10;        if (!open) dismiss()&#10;      },&#10;    },&#10;  })&#10;&#10;  return {&#10;    id: id,&#10;    dismiss,&#10;    update,&#10;  }&#10;}&#10;&#10;function useToast() {&#10;  const [state, setState] = React.useState&lt;State&gt;(memoryState)&#10;&#10;  React.useEffect(() =&gt; {&#10;    listeners.push(setState)&#10;    return () =&gt; {&#10;      const index = listeners.indexOf(setState)&#10;      if (index &gt; -1) {&#10;        listeners.splice(index, 1)&#10;      }&#10;    }&#10;  }, [state])&#10;&#10;  return {&#10;    ...state,&#10;    toast,&#10;    dismiss: (toastId?: string) =&gt; dispatch({ type: 'DISMISS_TOAST', toastId }),&#10;  }&#10;}&#10;&#10;export { useToast, toast }&#10;" />
              <option name="updatedContent" value="'use client'&#10;&#10;// Inspired by react-hot-toast library&#10;import * as React from 'react'&#10;&#10;import type { ToastActionElement, ToastProps } from '@/components/ui/toast'&#10;&#10;const TOAST_LIMIT = 1&#10;const TOAST_REMOVE_DELAY = 1000000&#10;&#10;type ToasterToast = ToastProps &amp; {&#10;  id: string&#10;  title?: React.ReactNode&#10;  description?: React.ReactNode&#10;  action?: ToastActionElement&#10;}&#10;&#10;let count = 0&#10;&#10;function genId() {&#10;  count = (count + 1) % Number.MAX_SAFE_INTEGER&#10;  return count.toString()&#10;}&#10;&#10;type Action =&#10;  | {&#10;      type: 'ADD_TOAST'&#10;      toast: ToasterToast&#10;    }&#10;  | {&#10;      type: 'UPDATE_TOAST'&#10;      toast: Partial&lt;ToasterToast&gt;&#10;    }&#10;  | {&#10;      type: 'DISMISS_TOAST'&#10;      toastId?: ToasterToast['id']&#10;    }&#10;  | {&#10;      type: 'REMOVE_TOAST'&#10;      toastId?: ToasterToast['id']&#10;    }&#10;&#10;interface State {&#10;  toasts: ToasterToast[]&#10;}&#10;&#10;const toastTimeouts = new Map&lt;string, ReturnType&lt;typeof setTimeout&gt;&gt;()&#10;&#10;const addToRemoveQueue = (toastId: string) =&gt; {&#10;  if (toastTimeouts.has(toastId)) {&#10;    return&#10;  }&#10;&#10;  const timeout = setTimeout(() =&gt; {&#10;    toastTimeouts.delete(toastId)&#10;    dispatch({&#10;      type: 'REMOVE_TOAST',&#10;      toastId: toastId,&#10;    })&#10;  }, TOAST_REMOVE_DELAY)&#10;&#10;  toastTimeouts.set(toastId, timeout)&#10;}&#10;&#10;export const reducer = (state: State, action: Action): State =&gt; {&#10;  switch (action.type) {&#10;    case 'ADD_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),&#10;      }&#10;&#10;    case 'UPDATE_TOAST':&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === action.toast.id ? { ...t, ...action.toast } : t,&#10;        ),&#10;      }&#10;&#10;    case 'DISMISS_TOAST': {&#10;      const { toastId } = action&#10;&#10;      // ! Side effects ! - This could be extracted into a dismissToast() action,&#10;      // but I'll keep it here for simplicity&#10;      if (toastId) {&#10;        addToRemoveQueue(toastId)&#10;      } else {&#10;        state.toasts.forEach((toast) =&gt; {&#10;          addToRemoveQueue(toast.id)&#10;        })&#10;      }&#10;&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.map((t) =&gt;&#10;          t.id === toastId || toastId === undefined&#10;            ? {&#10;                ...t,&#10;                open: false,&#10;              }&#10;            : t,&#10;        ),&#10;      }&#10;    }&#10;    case 'REMOVE_TOAST':&#10;      if (action.toastId === undefined) {&#10;        return {&#10;          ...state,&#10;          toasts: [],&#10;        }&#10;      }&#10;      return {&#10;        ...state,&#10;        toasts: state.toasts.filter((t) =&gt; t.id !== action.toastId),&#10;      }&#10;  }&#10;}&#10;&#10;const listeners: Array&lt;(state: State) =&gt; void&gt; = []&#10;&#10;let memoryState: State = { toasts: [] }&#10;&#10;function dispatch(action: Action) {&#10;  memoryState = reducer(memoryState, action)&#10;  listeners.forEach((listener) =&gt; {&#10;    listener(memoryState)&#10;  })&#10;}&#10;&#10;type Toast = Omit&lt;ToasterToast, 'id'&gt;&#10;&#10;function toast({ ...props }: Toast) {&#10;  const id = genId()&#10;&#10;  const update = (props: ToasterToast) =&gt;&#10;    dispatch({&#10;      type: 'UPDATE_TOAST',&#10;      toast: { ...props, id },&#10;    })&#10;  const dismiss = () =&gt; dispatch({ type: 'DISMISS_TOAST', toastId: id })&#10;&#10;  dispatch({&#10;    type: 'ADD_TOAST',&#10;    toast: {&#10;      ...props,&#10;      id,&#10;      open: true,&#10;      onOpenChange: (open) =&gt; {&#10;        if (!open) dismiss()&#10;      },&#10;    },&#10;  })&#10;&#10;  return {&#10;    id: id,&#10;    dismiss,&#10;    update,&#10;  }&#10;}&#10;&#10;function useToast() {&#10;  const [state, setState] = React.useState&lt;State&gt;(memoryState)&#10;&#10;  React.useEffect(() =&gt; {&#10;    listeners.push(setState)&#10;    return () =&gt; {&#10;      const index = listeners.indexOf(setState)&#10;      if (index &gt; -1) {&#10;        listeners.splice(index, 1)&#10;      }&#10;    }&#10;  }, [state])&#10;&#10;  return {&#10;    ...state,&#10;    toast,&#10;    dismiss: (toastId?: string) =&gt; dispatch({ type: 'DISMISS_TOAST', toastId }),&#10;  }&#10;}&#10;&#10;export { useToast, toast }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>